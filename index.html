<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNTOOL - CLOUD VERIFIED</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css">
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #06080f;
            --brand-glow: rgba(59, 130, 246, 0.4);
        }
        body {
            background-color: var(--bg-color);
            color: #f8fafc;
            font-family: 'Plus Jakarta Sans', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 90%;
            max-width: 420px;
            border-radius: 2.5rem;
            padding: 3rem;
            box-shadow: 0 40px 100px -20px rgba(0,0,0,0.8);
        }
        .btn-main {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            box-shadow: 0 10px 25px -5px var(--brand-glow);
            color: white;
            cursor: pointer;
        }
        .btn-main:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .key-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px dashed rgba(59, 130, 246, 0.5);
            font-family: 'JetBrains Mono', monospace;
        }
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-in {
            animation: fade-in-up 0.4s ease-out forwards;
        }
        .honeypot {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
        .turnstile-container {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="glass-card text-center">
        <!-- Logo Section -->
        <div style="width: 4rem; height: 4rem; background-color: #2563eb; border-radius: 1rem; margin: 0 auto 1.5rem; display: flex; align-items: center; justify-content: center; font-size: 1.875rem; font-weight: 900; box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.3);">DN</div>
        
        <!-- Header Section -->
        <h1 style="font-size: 1.5rem; font-weight: 900; margin-bottom: 0.25rem; font-style: italic;">DNTOOL <span style="color: #3b82f6; font-style: normal; font-weight: 300;">SYSTEM</span></h1>
        <p style="font-size: 0.625rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.3em; margin-bottom: 2.5rem; font-weight: 700;">H·ªá Th·ªëng X√°c Th·ª±c</p>

        <!-- Honeypot Field (hidden trap for bots) -->
        <input type="text" id="website" class="honeypot" tabindex="-1" autocomplete="off">

        <!-- Step 1: Action Button -->
        <div id="step-1">
            <!-- Cloudflare Turnstile Widget -->
            <div class="turnstile-container">
                <div class="cf-turnstile" 
                     data-sitekey="0x4AAAAAACNwFP1me9pXoX_D" 
                     data-callback="onTurnstileSuccess"
                     data-error-callback="onTurnstileError"
                     data-theme="dark"></div>
            </div>

            <button onclick="initiateKeyRequest()" id="btnAction" class="btn-main" style="width: 100%; padding: 1rem; border-radius: 1rem; font-weight: 700; display: flex; align-items: center; justify-content: center; gap: 0.75rem; transition: transform 0.2s; border: none;">
                <i class="fas fa-bolt"></i>
                <span id="btnText">NH·∫¨N M√É K√çCH HO·∫†T</span>
            </button>
            <p style="margin-top: 1.5rem; font-size: 0.6875rem; color: #64748b; line-height: 1.625; font-style: italic;">Y√™u c·∫ßu c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω an to√†n.</p>
        </div>

        <!-- Step 2: Result Display -->
        <div id="step-2" class="hidden animate-in">
            <div class="key-box" style="padding: 1.25rem; border-radius: 1rem; text-align: left;">
                <p style="font-size: 0.5625rem; color: #60a5fa; font-weight: 700; text-transform: uppercase; margin-bottom: 0.5rem;">Key c·ªßa b·∫°n:</p>
                <div id="resultKey" style="font-size: 0.875rem; font-weight: 700; color: white; word-break: break-all; margin-bottom: 1rem;">---</div>
                <button onclick="copyKeyToClipboard()" style="width: 100%; background-color: rgba(59, 130, 246, 0.1); padding: 0.75rem; border-radius: 0.75rem; font-size: 0.75rem; font-weight: 700; color: #60a5fa; transition: all 0.2s; border: 1px solid rgba(59, 130, 246, 0.2); cursor: pointer;">
                    SAO CH√âP NGAY
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            SERVER_URL: 'https://dntool-worker.nguyendangnhi1704.workers.dev/',
            RATE_LIMIT: {
                maxRequests: 5,
                timeWindow: 60000 // 60 seconds
            },
            PROOF_OF_WORK: {
                difficulty: 4,
                enabled: true
            },
            TURNSTILE_SITE_KEY: '0x4AAAAAACNwFP1me9pXoX_D',
            ENDPOINT_SIGNATURE_SECRET: 'DNTOOL-SIGNATURE-SECRET-2024' // Must match server
        };

        // ===== STATE MANAGEMENT =====
        const securityState = {
            requestHistory: [],
            csrfToken: null,
            userInteractions: { mouse: 0, keyboard: 0 },
            sessionStart: Date.now(),
            turnstileToken: null,
            turnstileVerified: false
        };

        // ===== TURNSTILE CALLBACKS =====
        function onTurnstileSuccess(token) {
            securityState.turnstileToken = token;
            securityState.turnstileVerified = true;
        }

        function onTurnstileError() {
            securityState.turnstileToken = null;
            securityState.turnstileVerified = false;
            alert("‚ùå L·ªói x√°c th·ª±c Turnstile!\n\nVui l√≤ng t·∫£i l·∫°i trang v√† th·ª≠ l·∫°i.");
        }

        // ===== UTILITY FUNCTIONS =====
        function generateCSRFToken() {
            const randomBytes = new Uint8Array(32);
            crypto.getRandomValues(randomBytes);
            return btoa(String.fromCharCode(...randomBytes));
        }

        function generateRequestId() {
            return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ===== DEVICE FINGERPRINTING =====
        function getDeviceFingerprint() {
            let deviceId = localStorage.getItem('device_id');
            
            if (!deviceId) {
                let canvasHash = '';
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.textBaseline = 'top';
                        ctx.font = '14px Arial';
                        ctx.fillText('Device fingerprint', 2, 2);
                        canvasHash = canvas.toDataURL();
                    }
                } catch (e) {
                    canvasHash = crypto.randomUUID();
                }
                
                deviceId = 'DEVICE_' + btoa((canvasHash || 'fallback') + Date.now()).replace(/[^a-zA-Z0-9]/g, '').slice(0, 32);
                localStorage.setItem('device_id', deviceId);
            }
            
            return deviceId;
        }

        // ===== RATE LIMITING =====
        function checkRateLimit() {
            const currentTime = Date.now();
            securityState.requestHistory = securityState.requestHistory.filter(
                timestamp => currentTime - timestamp < CONFIG.RATE_LIMIT.timeWindow
            );
            
            if (securityState.requestHistory.length >= CONFIG.RATE_LIMIT.maxRequests) {
                const oldestRequest = Math.min(...securityState.requestHistory);
                const waitTime = CONFIG.RATE_LIMIT.timeWindow - (currentTime - oldestRequest);
                throw new Error(`‚è±Ô∏è Qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng ƒë·ª£i ${Math.ceil(waitTime/1000)} gi√¢y.`);
            }
            
            securityState.requestHistory.push(currentTime);
        }

        // ===== ANTI-BOT DETECTION =====
        function detectBotActivity() {
            const sessionDuration = Date.now() - securityState.sessionStart;
            
            const honeypotField = document.getElementById('website');
            if (honeypotField && honeypotField.value.trim() !== '') {
                return false;
            }
            
            if (sessionDuration < 1000) {
                return false;
            }
            
            if (sessionDuration > 2000 && securityState.userInteractions.mouse === 0 && securityState.userInteractions.keyboard === 0) {
                return false;
            }
            
            return true;
        }

        // ===== PROOF OF WORK =====
        async function generateProofOfWork(challenge) {
            if (!CONFIG.PROOF_OF_WORK.enabled) {
                return 'disabled';
            }

            const difficulty = CONFIG.PROOF_OF_WORK.difficulty;
            const target = '0'.repeat(difficulty);
            let nonce = 0;
            let hash = '';

            while (true) {
                const input = challenge + nonce;
                const encoder = new TextEncoder();
                const data = encoder.encode(input);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                if (hash.startsWith(target)) {
                    return { nonce, hash };
                }

                nonce++;

                if (nonce > 1000000) {
                    throw new Error('Proof of work timeout');
                }
            }
        }

        // ===== ENDPOINT SIGNATURE =====
        async function generateEndpointSignature(endpoint, timestamp, deviceId) {
            const secret = CONFIG.ENDPOINT_SIGNATURE_SECRET;
            const combined = `${endpoint}:${timestamp}:${deviceId}`;
            
            const encoder = new TextEncoder();
            const keyData = encoder.encode(secret);
            const messageData = encoder.encode(combined);
            
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            
            const signatureBuffer = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
            const signature = Array.from(new Uint8Array(signatureBuffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
            
            return signature;
        }

        // ===== MAIN REQUEST FUNCTION =====
        async function initiateKeyRequest() {
            const urlParams = new URLSearchParams(window.location.search);
            const userId = urlParams.get('id');
            const userToken = urlParams.get('token');

            if (!userId) {
                alert("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y th√¥ng tin!\n\nVui l√≤ng truy c·∫≠p t·ª´ app ƒë·ªÉ s·ª≠ d·ª•ng d·ªãch v·ª•.");
                return;
            }

            // Check Turnstile verification
            if (!securityState.turnstileVerified || !securityState.turnstileToken) {
                alert("‚ùå Vui l√≤ng x√°c th·ª±c b·∫°n kh√¥ng ph·∫£i l√† robot!");
                return;
            }

            const btnAction = document.getElementById('btnAction');
            const btnText = document.getElementById('btnText');
            
            btnAction.disabled = true;
            btnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêANG X·ª¨ L√ù...';

            try {
                checkRateLimit();
                
                if (!detectBotActivity()) {
                    throw new Error('ü§ñ Ph√°t hi·ªán ho·∫°t ƒë·ªông b·∫•t th∆∞·ªùng.\n\nVui l√≤ng th·ª≠ l·∫°i sau v√†i gi√¢y.');
                }

                const deviceId = getDeviceFingerprint();
                const timestamp = Date.now().toString();
                const endpoint = '/github/generate_24h_key';
                
                if (!securityState.csrfToken) {
                    securityState.csrfToken = generateCSRFToken();
                }

                btnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêANG X√ÅC TH·ª∞C...';
                const powChallenge = timestamp + deviceId;
                const proofOfWork = await generateProofOfWork(powChallenge);
                
                // Generate endpoint signature
                const endpointSignature = await generateEndpointSignature(endpoint, timestamp, deviceId);

                const payload = {
                    action: 'generate_24h_key',
                    module: 'github',
                    key_input: userToken || 'DEMO-KEY-12345',
                    device_id: deviceId,
                    csrf_token: securityState.csrfToken,
                    user_agent: navigator.userAgent,
                    timestamp: timestamp,
                    proof_of_work: proofOfWork,
                    turnstile_token: securityState.turnstileToken,
                    endpoint: endpoint,
                    endpoint_signature: endpointSignature
                };

                btnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêANG K·∫æT N·ªêI...';
                const response = await fetch(CONFIG.SERVER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Device-ID': deviceId
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    if (response.status === 429) {
                        throw new Error('‚è±Ô∏è Qu√° nhi·ªÅu y√™u c·∫ßu!\n\nVui l√≤ng ƒë·ª£i 1 ph√∫t r·ªìi th·ª≠ l·∫°i.');
                    } else if (response.status === 403) {
                        throw new Error('üö´ Truy c·∫≠p b·ªã t·ª´ ch·ªëi!\n\nX√°c th·ª±c b·∫£o m·∫≠t th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i.');
                    }
                    throw new Error(`‚ùå L·ªói server: ${response.status}\n\nVui l√≤ng th·ª≠ l·∫°i sau.`);
                }
                
                const result = await response.json();

                if (result.success && result.data) {
                    document.getElementById('resultKey').innerText = result.data.key || 'ACTIVE-USER-' + deviceId.slice(-8);
                    document.getElementById('step-1').classList.add('hidden');
                    document.getElementById('step-2').classList.remove('hidden');
                    
                    securityState.csrfToken = generateCSRFToken();
                } else {
                    const errorMsg = result.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh";
                    alert("‚ùå Y√™u c·∫ßu b·ªã t·ª´ ch·ªëi!\n\n" + errorMsg + "\n\nVui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin v√† th·ª≠ l·∫°i.");
                    btnAction.disabled = false;
                    btnText.innerHTML = '<i class="fas fa-redo"></i> TH·ª¨ L·∫†I';
                }
            } catch (error) {
                alert("‚ùå L·ªói b·∫£o m·∫≠t:\n\n" + error.message);
                btnAction.disabled = false;
                btnText.innerHTML = '<i class="fas fa-redo"></i> TH·ª¨ L·∫†I';
            }
        }

        // ===== CLIPBOARD FUNCTIONS =====
        function copyKeyToClipboard() {
            const keyText = document.getElementById('resultKey').innerText;
            if (keyText === '---') return;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(keyText).then(() => {
                    alert("‚úÖ ƒê√£ sao ch√©p m√£ Key!");
                }).catch(() => {
                    fallbackCopy(keyText);
                });
            } else {
                fallbackCopy(keyText);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            alert("‚úÖ ƒê√£ sao ch√©p m√£ Key!");
        }

        // ===== SECURITY PROTECTIONS =====
        document.addEventListener('mousemove', () => securityState.userInteractions.mouse++);
        document.addEventListener('keydown', () => securityState.userInteractions.keyboard++);

        document.addEventListener('contextmenu', e => e.preventDefault());

        document.addEventListener('keydown', e => {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
                (e.ctrlKey && e.key === 'u')) {
                e.preventDefault();
            }
        });

        window.addEventListener('load', () => {
            securityState.csrfToken = generateCSRFToken();
        });
    </script>
</body>
</html>
