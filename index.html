<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="DNTOOL - H·ªá th·ªëng x√°c th·ª±c key b·∫£n quy·ªÅn 24h">
    <meta name="robots" content="noindex, nofollow">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <title>DNTOOL - CLOUD VERIFIED</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css">
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #06080f;
            --brand-glow: rgba(59, 130, 246, 0.4);
        }
        body {
            background-color: var(--bg-color);
            color: #f8fafc;
            font-family: 'Plus Jakarta Sans', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 95%;
            max-width: 400px;
            border-radius: 1.5rem;
            padding: 1.5rem;
            box-shadow: 0 40px 100px -20px rgba(0,0,0,0.8);
            margin: 1rem;
        }
        .btn-main {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            box-shadow: 0 10px 25px -5px var(--brand-glow);
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(0);
            font-size: 0.875rem;
            padding: 0.875rem;
        }
        .btn-main:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 15px 35px -5px var(--brand-glow);
        }
        .btn-main:active:not(:disabled) {
            transform: translateY(0);
        }
        .btn-main:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .btn-processing {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            box-shadow: 0 10px 25px -5px rgba(245, 158, 11, 0.4);
        }
        .btn-error {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 10px 25px -5px rgba(239, 68, 68, 0.4);
        }
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            box-shadow: 0 10px 25px -5px rgba(16, 185, 129, 0.4);
        }
        .key-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px dashed rgba(59, 130, 246, 0.5);
            font-family: 'JetBrains Mono', monospace;
        }
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-in {
            animation: fade-in-up 0.4s ease-out forwards;
        }
        .honeypot {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 0.875rem;
            border-radius: 0.75rem;
            font-size: 0.8125rem;
            margin-top: 1rem;
            animation: shake 0.5s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .turnstile-container {
            display: flex;
            justify-content: center;
            margin: 1rem 0;
            transform: scale(0.9);
            transform-origin: center;
        }
        
        /* Mobile Responsive */
        @media (max-width: 480px) {
            .glass-card {
                width: 98%;
                max-width: none;
                padding: 1.25rem;
                margin: 0.5rem;
                border-radius: 1rem;
            }
            
            body {
                padding: 0.5rem;
            }
            
            .btn-main {
                font-size: 0.8125rem;
                padding: 0.75rem;
            }
            
            .turnstile-container {
                transform: scale(0.85);
            }
        }
        
        @media (max-width: 360px) {
            .glass-card {
                padding: 1rem;
            }
            
            .btn-main {
                font-size: 0.75rem;
                padding: 0.625rem;
            }
            
            h1 {
                font-size: 1.125rem !important;
            }
            
            .turnstile-container {
                transform: scale(0.8);
            }
        }
    </style>
</head>
<body>
    <div class="glass-card text-center">
        <!-- Logo Section -->
        <div style="width: 3rem; height: 3rem; background-color: #2563eb; border-radius: 0.75rem; margin: 0 auto 1rem; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; font-weight: 900; box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.3);">DN</div>
        
        <!-- Header Section -->
        <h1 style="font-size: 1.25rem; font-weight: 900; margin-bottom: 0.25rem; font-style: italic;">DNTOOL <span style="color: #3b82f6; font-style: normal; font-weight: 300;">PRO</span></h1>
        <p style="font-size: 0.6875rem; color: #64748b; text-transform: uppercase; letter-spacing: 0.2em; margin-bottom: 1.5rem; font-weight: 700;">H·ªá Th·ªëng X√°c Th·ª±c</p>

        <!-- Honeypot Fields (hidden traps for bots) -->
        <input type="text" id="website" class="honeypot" tabindex="-1" autocomplete="off">
        <input type="text" id="email" class="honeypot" tabindex="-1" autocomplete="off">
        <input type="text" id="phone" class="honeypot" tabindex="-1" autocomplete="off">
        
        <!-- Error Message Display -->
        <div id="errorMessage" class="error-message hidden" style="margin-bottom: 1rem;">
            <span id="errorText" style="color: #fca5a5; font-size: 0.75rem;"></span>
        </div>

        <!-- Step 1: Action Button -->
        <div id="step-1">
            <!-- Cloudflare Turnstile Widget -->
            <div class="turnstile-container">
                <div class="cf-turnstile" 
                     data-sitekey="0x4AAAAAACNwFP1me9pXoX_D" 
                     data-callback="onTurnstileSuccess"
                     data-error-callback="onTurnstileError"
                     data-theme="dark"
                     data-action="keygen"></div>
            </div>

            <button onclick="initiateKeyRequest()" id="btnAction" class="btn-main" style="width: 100%; padding: 0.875rem; border-radius: 0.75rem; font-weight: 700; display: flex; align-items: center; justify-content: center; transition: transform 0.2s; border: none; font-size: 0.875rem;" disabled>
                <span id="btnText">ƒêANG KH·ªûI T·∫†O...</span>
            </button>
            <p style="margin-top: 1rem; font-size: 0.75rem; color: #64748b; line-height: 1.5; font-style: italic;">Y√™u c·∫ßu c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω an to√†n v√† b·∫£o m·∫≠t.</p>
        </div>

        <!-- Step 2: Result Display -->
        <div id="step-2" class="hidden animate-in">
            <div class="key-box" style="padding: 1rem; border-radius: 0.75rem; text-align: left;">
                <p style="font-size: 0.625rem; color: #60a5fa; font-weight: 700; text-transform: uppercase; margin-bottom: 0.5rem;">Key c·ªßa b·∫°n:</p>
                <div id="resultKey" style="font-size: 0.75rem; font-weight: 700; color: white; word-break: break-all; margin-bottom: 0.875rem;">---</div>
                <button onclick="copyKeyToClipboard()" style="width: 100%; background-color: rgba(59, 130, 246, 0.1); padding: 0.625rem; border-radius: 0.625rem; font-size: 0.75rem; font-weight: 700; color: #60a5fa; transition: all 0.2s; border: 1px solid rgba(59, 130, 246, 0.2); cursor: pointer;">
                    SAO CH√âP NGAY
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== CONSTANTS =====
        const TIMEOUTS = {
            TURNSTILE_CHECK: 3000,
            ERROR_HIDE: 10000,
            BUTTON_RESET: 2000
        };

        const VALIDATION = {
            USER_ID_MIN: 1,
            USER_ID_MAX: 10,
            DEVICE_ID_MIN: 3,
            DEVICE_ID_MAX: 100,
            SESSION_MIN: 1000,
            INTERACTION_CHECK: 2000
        };

        // ===== CONFIGURATION =====
        const CONFIG = {
            SERVER_URL: 'https://dntool-worker.nguyendangnhi1704.workers.dev/',
            RATE_LIMIT: {
                maxRequests: 5,
                timeWindow: 60000 // 60 seconds
            },
            PROOF_OF_WORK: {
                difficulty: 3,
                enabled: true
            },
            TURNSTILE_SITE_KEY: '0x4AAAAAACNwFP1me9pXoX_D',
            REQUIRE_TURNSTILE: true,
            DEBUG: false,
          
        };

        // ===== STATE MANAGEMENT =====
        const securityState = {
            requestHistory: [],
            csrfToken: null,
            userInteractions: { mouse: 0, keyboard: 0 },
            sessionStart: Date.now(),
            turnstileToken: null,
            turnstileVerified: false
        };
        
        // ===== UI STATE MANAGEMENT =====
        const uiState = {
            currentStatus: 'idle',
            errorMessage: '',
            userId: null,
            userToken: null,
            deviceId: null
        };

        // ===== DEBUG HELPER =====
        function debugLog(method, ...args) {
            if (CONFIG.DEBUG) {
                console[method](...args);
            }
        }

        // ===== UTILITY FUNCTIONS =====
        function generateCSRFToken() {
            const randomBytes = new Uint8Array(32);
            crypto.getRandomValues(randomBytes);
            return btoa(String.fromCharCode(...randomBytes));
        }

        function generateRequestId() {
            return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ===== ERROR HANDLING =====
        function handleError(error, context = '') {
            const message = error.message || error;
            debugLog('error', `Error in ${context}:`, message);
            showError(message);
            updateButtonState('error', 'L·ªñI');
            
            setTimeout(() => {
                if (typeof uiState !== 'undefined') {
                    updateButtonState('idle', 'TH·ª¨ L·∫†I');
                }
            }, TIMEOUTS.BUTTON_RESET);
        }

        // ===== UI HELPER FUNCTIONS =====
        function updateButtonState(status, text) {
            const btnAction = document.getElementById('btnAction');
            const btnText = document.getElementById('btnText');
            
            // Remove all state classes
            btnAction.classList.remove('btn-processing', 'btn-error', 'btn-success');
            
            // Add new state classes and update content
            switch(status) {
                case 'processing':
                    btnAction.classList.add('btn-processing');
                    btnAction.disabled = true;
                    break;
                case 'error':
                    btnAction.classList.add('btn-error');
                    btnAction.disabled = false;
                    break;
                case 'success':
                    btnAction.classList.add('btn-success');
                    btnAction.disabled = true;
                    break;
                default: // idle
                    btnAction.disabled = false;
            }
            
            // Update button text
            if (text) btnText.textContent = text;
            
            // Only update uiState if it's defined
            if (typeof uiState !== 'undefined') {
                uiState.currentStatus = status;
            }
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            
            errorText.textContent = message;
            errorDiv.classList.remove('hidden');
            if (typeof uiState !== 'undefined') {
                uiState.errorMessage = message;
            }
            
            // Auto-hide error after timeout
            setTimeout(() => {
                errorDiv.classList.add('hidden');
                if (typeof uiState !== 'undefined') {
                    uiState.errorMessage = '';
                }
            }, TIMEOUTS.ERROR_HIDE);
        }
        
        function hideError() {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.classList.add('hidden');
            if (typeof uiState !== 'undefined') {
                uiState.errorMessage = '';
            }
        }

        // ===== TURNSTILE CALLBACKS =====
        let turnstileLoaded = false;
        
        function onTurnstileSuccess(token) {
            debugLog('log', 'Turnstile success:', token);
            securityState.turnstileToken = token;
            securityState.turnstileVerified = true;
            turnstileLoaded = true;
            
            // Enable button immediately after verification
            const btnAction = document.getElementById('btnAction');
            if (btnAction) {
                btnAction.disabled = false;
                btnAction.style.opacity = '1';
            }
        }

        function onTurnstileError() {
            debugLog('error', 'Turnstile error');
            securityState.turnstileToken = null;
            securityState.turnstileVerified = false;
            turnstileLoaded = false;
            
            updateButtonState('error', 'L·ªñI X√ÅC TH·ª∞C');
            showError('X√°c th·ª±c Cloudflare th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i.');
        }
        
        // Check if Turnstile is loaded
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (!turnstileLoaded) {
                    if (CONFIG.REQUIRE_TURNSTILE) {
                        debugLog('error', 'Turnstile required but not loaded - blocking access');
                        updateButtonState('error', 'Y√äU C·∫¶U X√ÅC TH·ª∞C CLOUDFLARE');
                        showError('Vui l√≤ng b·∫≠t Cloudflare Turnstile v√† t·∫£i l·∫°i trang');
                    } else {
                        debugLog('warn', 'Turnstile not loaded, enabling button with fallback verification');
                        const btnAction = document.getElementById('btnAction');
                        if (btnAction) {
                            btnAction.disabled = false;
                            btnAction.style.opacity = '1';
                            updateButtonState('idle', 'NH·∫¨N M√É K√çCH HO·∫†T (FALLBACK)');
                        }
                    }
                }
            }, TIMEOUTS.TURNSTILE_CHECK);
        });

        // ===== RATE LIMITING =====
        function checkRateLimit() {
            const currentTime = Date.now();
            securityState.requestHistory = securityState.requestHistory.filter(
                timestamp => currentTime - timestamp < CONFIG.RATE_LIMIT.timeWindow
            );
            
            if (securityState.requestHistory.length >= CONFIG.RATE_LIMIT.maxRequests) {
                const oldestRequest = Math.min(...securityState.requestHistory);
                const waitTime = CONFIG.RATE_LIMIT.timeWindow - (currentTime - oldestRequest);
                throw new Error(`‚è±Ô∏è Qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng ƒë·ª£i ${Math.ceil(waitTime/1000)} gi√¢y.`);
            }
            
            securityState.requestHistory.push(currentTime);
        }

        // ===== ANTI-BOT DETECTION =====
        function detectBotActivity() {
            const sessionDuration = Date.now() - securityState.sessionStart;
            
            // Check multiple honeypot fields
            const honeypotFields = ['website', 'email', 'phone'];
            for (const fieldId of honeypotFields) {
                const field = document.getElementById(fieldId);
                if (field && field.value.trim() !== '') {
                    debugLog('warn', `Honeypot field ${fieldId} filled:`, field.value);
                    return false;
                }
            }
            
            // Check session duration
            if (sessionDuration < VALIDATION.SESSION_MIN) {
                debugLog('warn', 'Session too short:', sessionDuration);
                return false;
            }
            
            // Check user interactions
            if (sessionDuration > VALIDATION.INTERACTION_CHECK && securityState.userInteractions.mouse === 0 && securityState.userInteractions.keyboard === 0) {
                debugLog('warn', 'No user interactions detected');
                return false;
            }
            
            // Check for common bot behaviors
            if (navigator.webdriver) {
                debugLog('warn', 'WebDriver detected');
                return false;
            }
            
            return true;
        }

        // ===== INPUT VALIDATION =====
        function validateUserInput() {
            const urlParams = new URLSearchParams(window.location.search);
            const deviceId = urlParams.get('id');
            const userToken = urlParams.get('token');

            if (!deviceId) {
                throw new Error('Vui l√≤ng ƒëƒÉng nh·∫≠p t·ª´ App ƒë·ªÉ l·∫•y key');
            }

            // Parse user_id from userToken (format: userId-deviceId)
            let userId = null;
            if (userToken && userToken.includes('-')) {
                try {
                    const parts = userToken.split('-');
                    if (parts.length >= 2) {
                        userId = parseInt(parts[0]);
                        if (isNaN(userId) || userId <= 0) {
                            debugLog('warn', 'Invalid user_id parsed:', parts[0]);
                            userId = null;
                        } else {
                            debugLog('log', 'Successfully parsed user_id:', userId, 'from token:', userToken);
                        }
                    } else {
                        debugLog('warn', 'Invalid token format - not enough parts:', userToken);
                    }
                } catch (error) {
                    debugLog('error', 'Error parsing userToken:', error);
                    userId = null;
                }
            } else if (userToken) {
                debugLog('warn', 'Token exists but does not contain \'-\' separator:', userToken);
            } else {
                debugLog('warn', 'No userToken provided in URL');
            }

            if (!userId) {
                throw new Error('USER kh√¥ng h·ª£p l·ªá - Vui l√≤ng ƒëƒÉng nh·∫≠p t·ª´ App ƒë·ªÉ l·∫•y key');
            }

            // Store for later use - with safety check
            if (typeof uiState !== 'undefined') {
                uiState.userId = userId;
                uiState.userToken = userToken;
                uiState.deviceId = deviceId;
            } else {
                debugLog('error', 'uiState is not defined in validateUserInput');
                throw new Error('L·ªói kh·ªüi t·∫°o h·ªá th·ªëng - Vui l√≤ng t·∫£i l·∫°i trang');
            }

            // Additional validation for user_id
            if (userId.toString().length < VALIDATION.USER_ID_MIN || userId.toString().length > VALIDATION.USER_ID_MAX) {
                throw new Error('USER ID kh√¥ng h·ª£p l·ªá - ƒê·ªô d√†i ph·∫£i t·ª´ 1-10 ch·ªØ s·ªë');
            }
            
            // Check for suspicious characters (should be numeric only)
            if (!/^\d+$/.test(userId.toString())) {
                throw new Error('USER ID ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ s·ªë');
            }
            
            // Validate device ID format
            if (!deviceId || deviceId.length < VALIDATION.DEVICE_ID_MIN || deviceId.length > VALIDATION.DEVICE_ID_MAX) {
                throw new Error('DEVICE ID kh√¥ng h·ª£p l·ªá - ƒê·ªô d√†i ph·∫£i t·ª´ 3-100 k√Ω t·ª±');
            }
            
            debugLog('log', 'Validation successful - user_id:', userId, 'device_id:', deviceId);
            return true;
        }

        // ===== PROOF OF WORK =====
        async function generateProofOfWork(challenge) {
            if (!CONFIG.PROOF_OF_WORK.enabled) {
                return 'disabled';
            }

            const difficulty = CONFIG.PROOF_OF_WORK.difficulty;
            const target = '0'.repeat(difficulty);
            let nonce = 0;
            let hash = '';
            let iterations = 0;
            const maxIterations = 1000000;

            // Use setTimeout to prevent browser freezing
            return new Promise((resolve, reject) => {
                function computeNext() {
                    try {
                        const input = challenge + nonce;
                        const encoder = new TextEncoder();
                        const data = encoder.encode(input);
                        const hashBuffer = crypto.subtle.digest('SHA-256', data);
                        
                        hashBuffer.then(buffer => {
                            const hashArray = Array.from(new Uint8Array(buffer));
                            hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                            if (hash.startsWith(target)) {
                                resolve({ nonce, hash });
                                return;
                            }

                            nonce++;
                            iterations++;

                            if (iterations > maxIterations) {
                                reject(new Error('Proof of work timeout'));
                                return;
                            }

                            // Yield control to browser every 100 iterations
                            if (iterations % 100 === 0) {
                                setTimeout(computeNext, 0);
                            } else {
                                computeNext();
                            }
                        }).catch(error => {
                            reject(error);
                        });
                    } catch (error) {
                        reject(error);
                    }
                }
                
                computeNext();
            });
        }

        // ===== ENDPOINT SIGNATURE =====
        async function generateEndpointSignature(endpoint, timestamp, deviceId) {
            // Kh√¥ng d√πng APP_SESSION_ID ·ªü client - server s·∫Ω t·ª± verify
            const combined = `${endpoint}:${timestamp}:${deviceId}`;
            
            const encoder = new TextEncoder();
            const messageData = encoder.encode(combined);
            
            const hashBuffer = await crypto.subtle.digest('SHA-256', messageData);
            const signature = Array.from(new Uint8Array(hashBuffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
            
            return signature;
        }

        // ===== REQUEST PREPARATION =====
        function prepareRequestPayload() {
            if (typeof uiState === 'undefined') {
                throw new Error('L·ªói kh·ªüi t·∫°o h·ªá th·ªëng - uiState kh√¥ng kh·∫£ d·ª•ng');
            }
            
            const deviceId = uiState.deviceId;
            const timestamp = Date.now().toString();
            const endpoint = '/github/generate_24h_key';
            
            if (!securityState.csrfToken) {
                securityState.csrfToken = generateCSRFToken();
            }

            return {
                auth_key: "Mat_Ma_Sieu_Cap_123_be_tap_code_vip_pro_chong_hack_ha_ha",
                action: 'generate_24h_key',
                module: 'github',
                user_id: uiState.userId,
                key_input: uiState.userToken,
                device_id: deviceId,
                csrf_token: securityState.csrfToken,
                user_agent: navigator.userAgent,
                timestamp: timestamp,
                proof_of_work: null, // s·∫Ω ƒë∆∞·ª£c th√™m sau
                turnstile_token: securityState.turnstileToken,
                endpoint: endpoint,
                endpoint_signature: null // s·∫Ω ƒë∆∞·ª£c th√™m sau
            };
        }

        // ===== API REQUEST =====
        async function sendRequest(payload) {
            const response = await fetch(CONFIG.SERVER_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Device-ID': payload.device_id
                },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                if (response.status === 429) {
                    throw new Error('‚è±Ô∏è Qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng ƒë·ª£i 1 ph√∫t r·ªìi th·ª≠ l·∫°i.');
                } else if (response.status === 403) {
                    throw new Error('üö´ Truy c·∫≠p b·ªã t·ª´ ch·ªëi! X√°c th·ª±c b·∫£o m·∫≠t th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i.');
                }
                throw new Error(`‚ùå L·ªói server: ${response.status} Vui l√≤ng th·ª≠ l·∫°i sau.`);
            }
            
            return await response.json();
        }

        // ===== RESPONSE HANDLING =====
        function handleResponse(result) {
            if (result.success && result.data) {
                updateButtonState('success', 'TH√ÄNH C√îNG');
                const deviceSuffix = (typeof uiState !== 'undefined' && uiState.deviceId) ? uiState.deviceId.slice(-8) : 'UNKNOWN';
                document.getElementById('resultKey').innerText = result.data.key || 'ACTIVE-USER-' + deviceSuffix;
                document.getElementById('step-1').classList.add('hidden');
                document.getElementById('step-2').classList.remove('hidden');
                
                securityState.csrfToken = generateCSRFToken();
                return true;
            } else {
                const errorMsg = result.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh";
                throw new Error(errorMsg);
            }
        }

        // ===== MAIN REQUEST FUNCTION (Refactored) =====
        async function initiateKeyRequest() {
            try {
                hideError();
                
                // Validate input
                if (!validateUserInput()) {
                    updateButtonState('error', 'THI·∫æU TH√îNG TIN');
                    setTimeout(() => {
                        if (typeof uiState !== 'undefined') {
                            updateButtonState('idle', 'NH·∫¨N M√É K√çCH HO·∫†T');
                        }
                    }, TIMEOUTS.BUTTON_RESET);
                    return;
                }
                
                // Check Turnstile
                if (CONFIG.REQUIRE_TURNSTILE && !turnstileLoaded) {
                    throw new Error('üö´ Y√™u c·∫ßu x√°c th·ª±c Cloudflare Turnstile b·∫Øt bu·ªôc');
                } else if (!turnstileLoaded && (!securityState.turnstileVerified || !securityState.turnstileToken)) {
                    debugLog('warn', 'Turnstile not verified, proceeding with fallback mode');
                }
                
                updateButtonState('processing', 'ƒêANG X·ª¨ L√ù...');
                
                // Security checks
                checkRateLimit();
                if (!detectBotActivity()) {
                    throw new Error('ü§ñ Ph√°t hi·ªán ho·∫°t ƒë·ªông b·∫•t th∆∞·ªùng. Vui l√≤ng th·ª≠ l·∫°i sau v√†i gi√¢y.');
                }

                // Prepare request
                updateButtonState('processing', 'ƒêANG X√ÅC TH·ª∞C...');
                const payload = prepareRequestPayload();
                
                // Generate proof of work
                const powChallenge = payload.timestamp + payload.device_id;
                payload.proof_of_work = await generateProofOfWork(powChallenge);
                
                // Generate endpoint signature
                payload.endpoint_signature = await generateEndpointSignature(payload.endpoint, payload.timestamp, payload.device_id);

                // Send request
                updateButtonState('processing', 'ƒêANG K·∫æT N·ªêI...');
                const result = await sendRequest(payload);

                // Handle response
                handleResponse(result);
                
            } catch (error) {
                handleError(error, 'initiateKeyRequest');
            }
        }

        // ===== CLIPBOARD FUNCTIONS =====
        function copyKeyToClipboard() {
            const keyText = document.getElementById('resultKey').innerText;
            if (keyText === '---') return;
            
            const copyBtn = document.querySelector('button[onclick="copyKeyToClipboard()"]');
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(keyText).then(() => {
                    showCopySuccess(copyBtn);
                }).catch(() => {
                    fallbackCopy(keyText, copyBtn);
                });
            } else {
                fallbackCopy(keyText, copyBtn);
            }
        }
        
        function showCopySuccess(copyBtn) {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'ƒê√É SAO CH√âP!';
            copyBtn.style.backgroundColor = 'rgba(16, 185, 129, 0.2)';
            copyBtn.style.borderColor = 'rgba(16, 185, 129, 0.3)';
            copyBtn.style.color = '#34d399';
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                copyBtn.style.borderColor = 'rgba(59, 130, 246, 0.2)';
                copyBtn.style.color = '#60a5fa';
            }, TIMEOUTS.BUTTON_RESET);
        }

        function fallbackCopy(text, copyBtn) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            showCopySuccess(copyBtn);
        }

        // ===== DEVICE FINGERPRINTING =====
        function getDeviceFingerprint() {
            let deviceId = localStorage.getItem('device_id');
            
            if (!deviceId) {
                let canvasHash = '';
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.textBaseline = 'top';
                        ctx.font = '14px Arial';
                        ctx.fillText('Device fingerprint', 2, 2);
                        canvasHash = canvas.toDataURL();
                    }
                } catch (e) {
                    canvasHash = crypto.randomUUID();
                }
                
                deviceId = 'DEVICE_' + btoa((canvasHash || 'fallback') + Date.now()).replace(/[^a-zA-Z0-9]/g, '').slice(0, 32);
                localStorage.setItem('device_id', deviceId);
            }
            
            return deviceId;
        }

        // ===== SECURITY PROTECTIONS =====
        document.addEventListener('mousemove', () => securityState.userInteractions.mouse++);
        document.addEventListener('keydown', () => securityState.userInteractions.keyboard++);

        document.addEventListener('contextmenu', e => e.preventDefault());

        document.addEventListener('keydown', e => {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
                (e.ctrlKey && e.key === 'u')) {
                e.preventDefault();
            }
        });

        // ===== INITIALIZATION =====
        window.addEventListener('load', () => {
            securityState.csrfToken = generateCSRFToken();
            
            // Validate user input on page load - BEFORE using uiState
            try {
                validateUserInput();
            } catch (error) {
                debugLog('warn', 'Invalid user input detected on page load:', error.message);
            }
            
            // Initialize button state - only after uiState is defined and validation is done
            setTimeout(() => {
                updateButtonState('idle', 'NH·∫¨N M√É K√çCH HO·∫†T');
            }, 100);
        });
    </script>
</body>
</html>


