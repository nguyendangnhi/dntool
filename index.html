<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNTOOL - CLOUD VERIFIED</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;800&family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #06080f;
            --brand-glow: rgba(59, 130, 246, 0.4);
        }
        body {
            background-color: var(--bg-color);
            color: #f8fafc;
            font-family: 'Plus Jakarta Sans', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 90%;
            max-width: 420px;
            border-radius: 2.5rem;
            padding: 3rem;
            box-shadow: 0 40px 100px -20px rgba(0,0,0,0.8);
        }
        .btn-main {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            box-shadow: 0 10px 25px -5px var(--brand-glow);
        }
        .key-box {
            background: rgba(0, 0, 0, 0.4);
            border: 1px dashed rgba(59, 130, 246, 0.5);
            font-family: 'JetBrains Mono', monospace;
        }
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-in {
            animation: fade-in-up 0.4s ease-out forwards;
        }
        .honeypot {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
    </style>
</head>
<body>
    <div class="glass-card text-center">
        <!-- Logo Section -->
        <div class="w-16 h-16 bg-blue-600 rounded-2xl mx-auto mb-6 flex items-center justify-center text-3xl font-black shadow-lg shadow-blue-500/30">DN</div>
        
        <!-- Header Section -->
        <h1 class="text-2xl font-black mb-1 italic">DNTOOL <span class="text-blue-500 not-italic font-light">SYSTEM</span></h1>
        <p class="text-[10px] text-slate-500 uppercase tracking-[0.3em] mb-10 font-bold">H·ªá Th·ªëng X√°c Th·ª±c</p>

        <!-- Honeypot Field (hidden trap for bots) -->
        <input type="text" id="website" class="honeypot" tabindex="-1" autocomplete="off">

        <!-- Step 1: Action Button -->
        <div id="step-1">
            <button onclick="initiateKeyRequest()" id="btnAction" class="btn-main w-full py-4 rounded-2xl font-bold flex items-center justify-center gap-3 transition-transform active:scale-95">
                <i class="fas fa-bolt"></i>
                <span id="btnText">NH·∫¨N M√É K√çCH HO·∫†T</span>
            </button>
            <p class="mt-6 text-[11px] text-slate-500 leading-relaxed italic">Y√™u c·∫ßu c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω an to√†n.</p>
        </div>

        <!-- Step 2: Result Display -->
        <div id="step-2" class="hidden animate-in">
            <div class="key-box p-5 rounded-2xl text-left">
                <p class="text-[9px] text-blue-400 font-bold uppercase mb-2">Key c·ªßa b·∫°n:</p>
                <div id="resultKey" class="text-sm font-bold text-white break-all mb-4">---</div>
                <button onclick="copyKeyToClipboard()" class="w-full bg-blue-500/10 hover:bg-blue-500/20 py-3 rounded-xl text-xs font-bold text-blue-400 transition-all border border-blue-500/20">
                    SAO CH√âP NGAY
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            SERVER_URL: 'https://dntool-worker.nguyendangnhi1704.workers.dev/',
            AUTH_KEY_BASE: 'Mat_Ma_Sieu_Cap_123_be_tap_code_vip_pro_chong_hack_ha_ha',
            RATE_LIMIT: {
                maxRequests: 5,
                timeWindow: 60000 // 60 seconds
            },
            PROOF_OF_WORK: {
                difficulty: 4, // Number of leading zeros required in hash
                enabled: true
            }
        };

        // ===== ENCRYPTION KEYS =====
        const ENCRYPTION_PARTS = [
            [0x55, 0x5f, 0x64, 0x5f, 0x5f, 0x5c, 0x4f, 0x40], // DNTOOL_P
            [0x70, 0x6d, 0x7d, 0x71, 0x67, 0x61, 0x77, 0x70], // RO_SECUR
            [0x76, 0x6c, 0x01, 0x03, 0x01, 0x06, 0x6c, 0x63], // E_2025_P
            [0x16, 0x0d, 0x12, 0x05, 0x10, 0x01, 0x1b, 0x17], // RIVATE_S
            [0x20, 0x27, 0x21, 0x20, 0x27, 0x2a, 0x55, 0x55]  // ERVER__
        ];

        // ===== STATE MANAGEMENT =====
        const securityState = {
            requestHistory: [],
            csrfToken: null,
            userInteractions: { mouse: 0, keyboard: 0 },
            sessionStart: Date.now()
        };

        // ===== UTILITY FUNCTIONS =====
        function generateAuthKey() {
            const timestamp = Date.now().toString().slice(-6);
            return CONFIG.AUTH_KEY_BASE + timestamp;
        }

        function generateEncryptionKey() {
            const keyBuffer = new Uint8Array(32);
            let offset = 0;
            
            for (const part of ENCRYPTION_PARTS) {
                for (let i = 0; i < part.length; i++) {
                    keyBuffer[offset + i] = part[i] ^ (0x11 + (offset % 4));
                }
                offset += part.length;
            }
            
            return keyBuffer.buffer.slice(0, 32);
        }

        function generateCSRFToken() {
            const randomBytes = new Uint8Array(32);
            crypto.getRandomValues(randomBytes);
            return btoa(String.fromCharCode(...randomBytes));
        }

        function generateRequestId() {
            return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ===== DEVICE FINGERPRINTING =====
        function getDeviceFingerprint() {
            let deviceId = localStorage.getItem('device_id');
            
            if (!deviceId) {
                let canvasHash = '';
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        ctx.textBaseline = 'top';
                        ctx.font = '14px Arial';
                        ctx.fillText('Device fingerprint', 2, 2);
                        canvasHash = canvas.toDataURL();
                    }
                } catch (e) {
                    canvasHash = crypto.randomUUID();
                }
                
                deviceId = 'DEVICE_' + btoa((canvasHash || 'fallback') + Date.now()).replace(/[^a-zA-Z0-9]/g, '').slice(0, 32);
                localStorage.setItem('device_id', deviceId);
            }
            
            return deviceId;
        }

        // ===== RATE LIMITING =====
        function checkRateLimit() {
            const currentTime = Date.now();
            securityState.requestHistory = securityState.requestHistory.filter(
                timestamp => currentTime - timestamp < CONFIG.RATE_LIMIT.timeWindow
            );
            
            if (securityState.requestHistory.length >= CONFIG.RATE_LIMIT.maxRequests) {
                const oldestRequest = Math.min(...securityState.requestHistory);
                const waitTime = CONFIG.RATE_LIMIT.timeWindow - (currentTime - oldestRequest);
                throw new Error(`‚è±Ô∏è Qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng ƒë·ª£i ${Math.ceil(waitTime/1000)} gi√¢y.`);
            }
            
            securityState.requestHistory.push(currentTime);
        }

        // ===== ANTI-BOT DETECTION =====
        function detectBotActivity() {
            const sessionDuration = Date.now() - securityState.sessionStart;
            
            // Check honeypot
            const honeypotField = document.getElementById('website');
            if (honeypotField && honeypotField.value.trim() !== '') {
                console.warn('Honeypot triggered - bot detected');
                return false;
            }
            
            // Check user interactions
            if (sessionDuration < 1000) {
                console.warn('Request too fast - possible bot');
                return false;
            }
            
            if (sessionDuration > 2000 && securityState.userInteractions.mouse === 0 && securityState.userInteractions.keyboard === 0) {
                console.warn('No user interactions detected');
                return false;
            }
            
            return true;
        }

        // ===== PROOF OF WORK =====
        async function generateProofOfWork(challenge) {
            if (!CONFIG.PROOF_OF_WORK.enabled) {
                return 'disabled';
            }

            const difficulty = CONFIG.PROOF_OF_WORK.difficulty;
            const target = '0'.repeat(difficulty);
            let nonce = 0;
            let hash = '';

            while (true) {
                const input = challenge + nonce;
                const encoder = new TextEncoder();
                const data = encoder.encode(input);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                if (hash.startsWith(target)) {
                    return { nonce, hash };
                }

                nonce++;

                // Prevent infinite loop
                if (nonce > 1000000) {
                    throw new Error('Proof of work timeout');
                }
            }
        }

        // ===== ENCRYPTION =====
        async function encryptPayload(data) {
            try {
                const encoder = new TextEncoder();
                const keyBuffer = generateEncryptionKey();
                
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    keyBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt']
                );

                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    cryptoKey,
                    encoder.encode(data)
                );

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                console.error('Encryption error:', error);
                throw error;
            }
        }

        // ===== HMAC SIGNATURE =====
        async function generateHMACSignature(timestamp, deviceId, payload) {
            const encoder = new TextEncoder();
            const authKey = generateAuthKey();
            const keyData = encoder.encode(authKey);
            
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );

            const message = `${timestamp}:${deviceId}:${JSON.stringify(payload)}`;
            const messageData = encoder.encode(message);
            
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
            return btoa(String.fromCharCode(...new Uint8Array(signature)));
        }

        // ===== ENDPOINT SIGNATURE =====
        function generateEndpointSignature(endpoint, timestamp, deviceId) {
            const combined = `${endpoint}:${timestamp}:${deviceId}`;
            const encoder = new TextEncoder();
            const data = encoder.encode(combined);
            return btoa(String.fromCharCode(...data.slice(0, 32)));
        }

        // ===== MAIN REQUEST FUNCTION =====
        async function initiateKeyRequest() {
            const urlParams = new URLSearchParams(window.location.search);
            const userId = urlParams.get('id');
            const userToken = urlParams.get('token');

            if (!userId) {
                alert("‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y th√¥ng tin!\n\nVui l√≤ng truy c·∫≠p t·ª´ app ƒë·ªÉ s·ª≠ d·ª•ng d·ªãch v·ª•.");
                return;
            }

            const btnAction = document.getElementById('btnAction');
            const btnText = document.getElementById('btnText');
            
            btnAction.disabled = true;
            btnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêANG X·ª¨ L√ù...';

            try {
                // Security checks
                checkRateLimit();
                
                if (!detectBotActivity()) {
                    throw new Error('ü§ñ Ph√°t hi·ªán ho·∫°t ƒë·ªông b·∫•t th∆∞·ªùng.\n\nVui l√≤ng th·ª≠ l·∫°i sau v√†i gi√¢y.');
                }

                // Generate security tokens
                const deviceId = getDeviceFingerprint();
                const timestamp = Date.now().toString();
                const endpoint = '/security/validate_key';
                
                if (!securityState.csrfToken) {
                    securityState.csrfToken = generateCSRFToken();
                }

                // Generate proof of work
                btnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêANG X√ÅC TH·ª∞C...';
                const powChallenge = timestamp + deviceId;
                const proofOfWork = await generateProofOfWork(powChallenge);

                // Prepare payload (NO IP ADDRESS - server will detect it)
                const payload = {
                    action: 'validate_key',
                    module: 'security',
                    key_input: userToken || 'DEMO-KEY-12345',
                    device_id: deviceId,
                    csrf_token: securityState.csrfToken,
                    user_agent: navigator.userAgent,
                    timestamp: timestamp,
                    proof_of_work: proofOfWork
                };

                // Encrypt payload
                const encryptedData = await encryptPayload(JSON.stringify(payload));

                // Generate signatures
                const hmacSignature = await generateHMACSignature(timestamp, deviceId, { 
                    data: encryptedData, 
                    endpoint: endpoint, 
                    timestamp: timestamp 
                });
                const endpointSignature = generateEndpointSignature(endpoint, timestamp, deviceId);

                // Send request to server
                btnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ƒêANG K·∫æT N·ªêI...';
                const response = await fetch(CONFIG.SERVER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Timestamp': timestamp,
                        'X-Device-ID': deviceId,
                        'X-Signature': hmacSignature,
                        'X-Endpoint-Signature': endpointSignature,
                        'X-CSRF-Token': securityState.csrfToken,
                        'X-User-Agent': btoa(navigator.userAgent),
                        'X-Request-ID': generateRequestId()
                    },
                    body: JSON.stringify({ 
                        data: encryptedData, 
                        endpoint: endpoint, 
                        timestamp: timestamp, 
                        csrf_token: securityState.csrfToken 
                    })
                });
                
                if (!response.ok) {
                    if (response.status === 429) {
                        throw new Error('‚è±Ô∏è Qu√° nhi·ªÅu y√™u c·∫ßu!\n\nVui l√≤ng ƒë·ª£i 1 ph√∫t r·ªìi th·ª≠ l·∫°i.');
                    } else if (response.status === 403) {
                        throw new Error('üö´ Truy c·∫≠p b·ªã t·ª´ ch·ªëi!\n\nX√°c th·ª±c b·∫£o m·∫≠t th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i.');
                    }
                    throw new Error(`‚ùå L·ªói server: ${response.status}\n\nVui l√≤ng th·ª≠ l·∫°i sau.`);
                }
                
                const result = await response.json();

                if (result.success && result.data) {
                    document.getElementById('resultKey').innerText = result.data.key || 'ACTIVE-USER-' + deviceId.slice(-8);
                    document.getElementById('step-1').classList.add('hidden');
                    document.getElementById('step-2').classList.remove('hidden');
                    
                    // Regenerate CSRF token
                    securityState.csrfToken = generateCSRFToken();
                } else {
                    const errorMsg = result.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh";
                    alert("‚ùå Y√™u c·∫ßu b·ªã t·ª´ ch·ªëi!\n\n" + errorMsg + "\n\nVui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin v√† th·ª≠ l·∫°i.");
                    btnAction.disabled = false;
                    btnText.innerHTML = '<i class="fas fa-redo"></i> TH·ª¨ L·∫†I';
                }
            } catch (error) {
                console.error('Security error:', error);
                alert("‚ùå L·ªói b·∫£o m·∫≠t:\n\n" + error.message);
                btnAction.disabled = false;
                btnText.innerHTML = '<i class="fas fa-redo"></i> TH·ª¨ L·∫†I';
            }
        }

        // ===== CLIPBOARD FUNCTIONS =====
        function copyKeyToClipboard() {
            const keyText = document.getElementById('resultKey').innerText;
            if (keyText === '---') return;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(keyText).then(() => {
                    alert("‚úÖ ƒê√£ sao ch√©p m√£ Key!");
                }).catch(() => {
                    fallbackCopy(keyText);
                });
            } else {
                fallbackCopy(keyText);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            alert("‚úÖ ƒê√£ sao ch√©p m√£ Key!");
        }

        // ===== SECURITY PROTECTIONS =====
        
        // Track user interactions
        document.addEventListener('mousemove', () => securityState.userInteractions.mouse++);
        document.addEventListener('keydown', () => securityState.userInteractions.keyboard++);

        // Anti-debug protection (enhanced)
        (function() {
            const debugProtection = function() {
                debugger;
            };
            
            setInterval(() => {
                debugProtection();
            }, 3000);
        })();

        // Disable right click
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Disable common dev shortcuts
        document.addEventListener('keydown', e => {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
                (e.ctrlKey && e.key === 'u')) {
                e.preventDefault();
            }
        });

        // Console protection
        const consoleProtection = setInterval(() => {
            console.clear();
        }, 5000);

        // Initialize CSRF token on load
        window.addEventListener('load', () => {
            securityState.csrfToken = generateCSRFToken();
        });
    </script>
</body>
</html>
